#include <usart.h>
#include "defines.h"
#include "kozos.h"
#include "intr.h"
#include "interrupt.h"
#include "lib.h"
#include "consdrv.h"

#define CONS_BUFFER_SIZE 40
#define CONSDRV_CMD_USE   'u' /* コンソール・ドライバの使用開始 */
#define CONSDRV_CMD_WRITE 'w' /* コンソールへの文字列出力 */
#define STATIC_SEND_CONS_BURREF_SIZE 4096
#define STATIC_RECV_CONS_BURREF_SIZE 128
#define TEMP_CONS_BURREF_SIZE 128

static struct consreg {
  kz_thread_id_t id; /* コンソールを利用するスレッド */
  int index;         /* 利用するシリアルの番号 */

  char *send_buf;    /* 送信バッファ */
  char *recv_buf;    /* 受信バッファ */
  int send_len;      /* 送信バッファ中のデータサイズ */
  int recv_len;      /* 受信バッファ中のデータサイズ */

  /* kozos.c の kz_msgbox と同様の理由で，ダミー・メンバでサイズ調整する */
  long dummy[3];
} consreg[CONSDRV_DEVICE_NUM];

#if USE_STATIC_BUFFER
typedef struct {
	uint8_t buf[STATIC_SEND_CONS_BURREF_SIZE];
	uint32_t wr_idx;
	uint32_t rd_idx;
}RING_BUF;
typedef struct {
	RING_BUF snd_consle_buffer;
	uint8_t snd_len;
	uint8_t rcv_consle_buffer[STATIC_RECV_CONS_BURREF_SIZE];
	uint32_t rcv_len;
	int8_t temporary_buffer[TEMP_CONS_BURREF_SIZE];
}STATIC_CONSOLE_BUFFER;
static STATIC_CONSOLE_BUFFER s_buf;
#define get_sbuf() &s_buf;
#endif

static initialized = 0;

static uint8_t get_buf(void)
{
	STATIC_CONSOLE_BUFFER *buf = get_sbuf();
	RING_BUF *ring_buf;
	uint8_t data;

	ring_buf = &(buf->snd_consle_buffer);

	data = ring_buf->buf[ring_buf->rd_idx++];

	ring_buf->rd_idx = ring_buf->rd_idx & (STATIC_SEND_CONS_BURREF_SIZE-1);

	return data;
}

static void set_buf(uint8_t data)
{
	STATIC_CONSOLE_BUFFER *buf = get_sbuf();
	RING_BUF *ring_buf;

	ring_buf = &(buf->snd_consle_buffer);

	ring_buf->buf[ring_buf->wr_idx++] = data;

	ring_buf->wr_idx = ring_buf->wr_idx & (STATIC_SEND_CONS_BURREF_SIZE-1);

	return;
}

static int get_difference_idx(void)
{
	STATIC_CONSOLE_BUFFER *buf = get_sbuf();
	RING_BUF *ring_buf;
	ring_buf = &(buf->snd_consle_buffer);
	return ring_buf->wr_idx - ring_buf->rd_idx;
}

/*
 * 以下の２つの関数(send_char(), send_string())は割込み処理とスレッドから
 * 呼ばれるが送信バッファを操作しており再入不可のため，スレッドから呼び出す
 * 場合は排他のため割込み禁止状態で呼ぶこと．
 */

/* 送信バッファの先頭１文字を送信する */
static void send_char(struct consreg *cons)
{
	int i;
	STATIC_CONSOLE_BUFFER *buf = get_sbuf();
#if USE_STATIC_BUFFER
	usart_send_byte(cons->index, get_buf());
#else
	usart_send_byte(cons->index, cons->send_buf[0]);
	cons->send_len--;
	/* 先頭文字を送信したので，１文字ぶんずらす */
	for (i = 0; i < cons->send_len; i++)
		cons->send_buf[i] = cons->send_buf[i + 1];
#endif
}

/* 文字列を送信バッファに書き込み送信開始する */
static void send_string(struct consreg *cons, char *str, int len)
{
	int i;
	STATIC_CONSOLE_BUFFER *buf = get_sbuf();
	for (i = 0; i < len; i++) { /* 文字列を送信バッファにコピー */
		if (str[i] == '\n') /* \n→\r\nに変換 */
#if USE_STATIC_BUFFER
			set_buf('\r') ;
		set_buf(str[i]);
#else
			cons->send_buf[cons->send_len++] = '\r';
		cons->send_buf[cons->send_len++] = str[i];
#endif
  }
  /*
   * 送信割込み無効ならば，送信開始されていないので送信開始する．
   * 送信割込み有効ならば送信開始されており，送信割込みの延長で
   * 送信バッファ内のデータが順次送信されるので，何もしなくてよい．
   */
#if USE_STATIC_BUFFER
  if (get_difference_idx() && !usart_intr_is_send_enable(cons->index)) {
    usart_intr_send_enable(cons->index); /* 送信割込み有効化 */
    send_char(cons); /* 送信開始 */
  }
#else
  if (cons->send_len && !usart_intr_is_send_enable(cons->index)) {
    usart_intr_send_enable(cons->index); /* 送信割込み有効化 */
    send_char(cons); /* 送信開始 */
  }
#endif
}

/*
 * 以下は割込みハンドラから呼ばれる割込み処理であり，非同期で
 * 呼ばれるので，ライブラリ関数などを呼び出す場合には注意が必要．
 * 基本として，以下のいずれかに当てはまる関数しか呼び出してはいけない．
 * ・再入可能である．
 * ・スレッドから呼ばれることは無い関数である．
 * ・スレッドから呼ばれることがあるが，割込み禁止で呼び出している．
 * また非コンテキスト状態で呼ばれるため，システム・コールは利用してはいけない．
 * (サービス・コールを利用すること)
 */
static int consdrv_intrproc(struct consreg *cons)
{
	unsigned char c;
	char *p;
	STATIC_CONSOLE_BUFFER *buf = get_sbuf();
	
	if (usart_is_rcv_enable(cons->index)) { /* 受信割込み */
		c = usart_recv_byte(cons->index);
		if (c == '\r') /* 改行コード変換(\r→\n) */
			c = '\n';
		
		send_string(cons, &c, 1); /* エコーバック処理 */
		
		if (cons->id) {
			if (c != '\n') {
			/* 改行でないなら，受信バッファにバッファリングする */
#if USE_STATIC_BUFFER
				buf->rcv_consle_buffer[buf->rcv_len++] = c;
#else
				cons->recv_buf[cons->recv_len++] = c;
#endif
			} else {
				/*
				 * Enterが押されたら，バッファの内容を
				 * コマンド処理スレッドに通知する．
				 * (割込みハンドラなので，サービス・コールを利用する)
				 */
#if USE_STATIC_BUFFER
				kx_send(MSGBOX_ID_CONSINPUT, buf->rcv_len, &(buf->rcv_consle_buffer));
				buf->rcv_len = 0;
#else
				p = kx_kmalloc(CONS_BUFFER_SIZE);
				memcpy(p, cons->recv_buf, cons->recv_len);
				kx_send(MSGBOX_ID_CONSINPUT, cons->recv_len, p);
				cons->recv_len = 0;
#endif
			}
		}
	}
	
	if (usart_is_send_enable(USART1)) { /* 送信割込み */
#if USE_STATIC_BUFFER
		if (!cons->id || (get_difference_idx() == 0)) {
#else
		if (!cons->id || !cons->send_len) {
#endif
			/* 送信データが無いならば，送信処理終了 */
			usart_intr_send_disable(cons->index);
		} else {
			/* 送信データがあるならば，引続き送信する */
			send_char(cons);
		}
	}
	
	return 0;
}

/* 割込みハンドラ */
static void consdrv_intr(void)
{
  int i;
  struct consreg *cons;

  for (i = 0; i < CONSDRV_DEVICE_NUM; i++) {
    cons = &consreg[i];
    if (cons->id) {
      if (usart_is_send_enable(cons->index) ||
	  usart_is_rcv_enable(cons->index))
	/* 割込みがあるならば，割込み処理を呼び出す */
	consdrv_intrproc(cons);
    }
  }
}

static int consdrv_init(void)
{
  memset(consreg, 0, sizeof(consreg));
  return 0;
}

/* コンソール・ドライバの使用開始をコンソール・ドライバに依頼する */
void consdrv_send_use(int index)
{
  char *p;
  p = kz_kmalloc(3);
  p[0] = '0';
  p[1] = CONSDRV_CMD_USE;
  p[2] = '0' + index;
  kz_send(MSGBOX_ID_CONSOUTPUT, 3, p);
}

/* コンソールへの文字列出力をコンソール・ドライバに依頼する */
void consdrv_send_write(char *str)
{
#if USE_STATIC_BUFFER
	char *p;
	int len;
	len = strlen(str);
	STATIC_CONSOLE_BUFFER *buf = get_sbuf();
	if (initialized) {
		buf->temporary_buffer[0] = '0';
		buf->temporary_buffer[1] = CONSDRV_CMD_WRITE;
		memcpy(&(buf->temporary_buffer[2]), str, len);
	
		kz_send(MSGBOX_ID_CONSOUTPUT, len + 2, buf->temporary_buffer);
	}
#else
	char *p;
	int len;
	len = strlen(str);

	p = kz_kmalloc(len + 2);
	p[0] = '0';
	p[1] = CONSDRV_CMD_WRITE;
	memcpy(&p[2], str, len);
	kz_send(MSGBOX_ID_CONSOUTPUT, len + 2, p);
#endif
}

/* スレッドからの要求を処理する */
static int consdrv_command(struct consreg *cons, kz_thread_id_t id,
			   int index, int size, char *command)
{
  switch (command[0]) {
  case CONSDRV_CMD_USE: /* コンソール・ドライバの使用開始 */
    cons->id = id;
    cons->index = command[1] - '0';
#if USE_STATIC_BUFFER
  	// 静的バッファの初期化
    memset(&s_buf, 0, sizeof(s_buf));
#else
    cons->send_buf = kz_kmalloc(CONS_BUFFER_SIZE);
    cons->recv_buf = kz_kmalloc(CONS_BUFFER_SIZE);
    cons->send_len = 0;
    cons->recv_len = 0;
#endif
    usart_open(cons->index);
    usart_init(cons->index, consdrv_intr);
    usart_intr_recv_enable(cons->index); /* 受信割込み有効化(受信開始) */
    initialized = 1;
    break;

  case CONSDRV_CMD_WRITE: /* コンソールへの文字列出力 */
    /*
     * send_string()では送信バッファを操作しており再入不可なので，
     * 排他のために割込み禁止にして呼び出す．
     */
    INTR_DISABLE;
    send_string(cons, command + 1, size - 1); /* 文字列の送信 */
    INTR_ENABLE;
    break;

  default:
    break;
  }

  return 0;
}

int consdrv_main(int argc, char *argv[])
{
  int size, index;
  kz_thread_id_t id;
  char *p;

  consdrv_init();
  //kz_setintr(SOFTVEC_TYPE_SERINTR, consdrv_intr); /* 割込みハンドラ設定 */

  while (1) {
    id = kz_recv(MSGBOX_ID_CONSOUTPUT, &size, &p);
    index = p[0] - '0';
    consdrv_command(&consreg[index], id, index, size - 1, p + 1);
#ifndef USE_STATIC_BUFFER
    kz_kmfree(p);
#endif
  }

  return 0;
}
